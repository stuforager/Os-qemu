# lab5
## 练习一
### 实验要求
`do_execv`函数调用`load_icode`来加载并解析一个处于内存中的ELF执行文件格式的应用程序。需要补充`load_icode`的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好`proc_struct`结构中的成员变量`trapframe`中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。

### 实验思考
在`do_execve`函数中，我们需要将用户态的程序加载到内核态。这里重点就是调用`load_icode`函数来。在`load_icode`函数中列出了这个函数的主要流程：
1. 创建一个新的`mm_struct`。
2. 创建一个新的PDT，将mm的`pgdir`设置为这个PDT的虚拟地址。
3. 读取ELF格式，检验其合法性，循环读取每一个程序段，将需要加载的段加载到内存中，设置相应段的权限。之后初始化BSS段，将其清零。
4. 设置用户栈。
5. 设置当前进程的`mm`,`cr3`,设置`satp`寄存器。
6. 设置`trapframe`，将`gpr.sp`指向用户栈顶；将`epc`设置为ELF文件的入口地址；设置sstatus寄存器，将`SSTATUS_SPP`设置为0，表示退出当前中断后进入用户态，将`SSTATUS_SPIE`位置为1，表示退出当前中断后开启中断。


### 实验代码
```c++
tf->gpr.sp = USTACKTOP;
tf->epc = elf->e_entry;
tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
```

### 问题解答
简要描述这个用户态进程被`ucore`选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过：

在lab4中，我们创建第0个内核线程时将`need_resched`标志直接置为1的方式来在运行初期就准备切换进程，然后调用`schedule`函数进行查找，只要找到一个就会调用`proc_run`函数来切换到新进程，此时保存了当前进程上下文、切换页表，并调用`swicth_to`函数赋值、切换进程等。

但是在lab5的`init_main`函数中再次调用了`kernel_thread`去创建用户态进程，这里的进程执行的函数名为`user_main`。该函数会调用`KERNEL_EXECVE`宏来触发系统调用。

这个用户进程的函数在指导书中提到，它通过取巧的方式直接运行`ebreak`指令，来产生断点中断。并且设置a7寄存器的值为10说明这是内核进程产生的中断。当`ebreak`中断发生时，操作系统会在`trap.c`中处理该中断。从`syscall`函数到最终调用`sys_exec`函数。`sys_exec`会进一步调用`do_execve`，再调用`load_icode`函数来加载用户的二进制程序。这个函数主要负责加载应用程序执行码与建立用户环境：包括读取ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。把`mm->pgdir`赋值到cr3寄存器中，更新了用户进程的虚拟内存空间。

在完成`load_icode`后，内核将会创建一个新的进程`user_main`。然而，这个进程并不会立刻执行，而是继续执行`init_main`函数中的后续逻辑。此时，`init_main`会调用`do_wait`等函数来释放资源。同时父进程进入睡眠状态，等待子进程的完成。

当调度器选择`user_main`进程时，操作系统会按照前述过程加载ELF文件并执行。加载完成后，调用`kernel_execve_ret`，并通过`sret`指令从内核态返回到用户态。此时，程序开始执行用户程序的入口代码，执行了`initcode.S`中的第一条代码。

## 练习2: 父进程复制自己的内存空间给子进程

### 设计实现过程
copy_range函数的调用过程：do_fork()---->copy_mm()---->dup_mmap()---->copy_range()。

主要是设计实现`copy_range`的过程，以下就是`copy_range`的过程

#### 1. 找到源页面的内核虚拟地址（src_kvaddr）

在COW机制中，当发生写操作时，需要复制共享页面。首先，需要获取源页面的内核虚拟地址，这可以通过`page2kva`宏实现，该宏将页面结构体转换为对应的内核虚拟地址。

```c
uintptr_t src_kvaddr = page2kva(page);
```

#### 2. 找到目标页面的内核虚拟地址（dst_kvaddr）

在复制页面时，需要为目标页面分配一个新的物理页，并获取其内核虚拟地址。这同样可以通过`page2kva`宏实现。

```c
uintptr_t dst_kvaddr = page2kva(npage);
```

#### 3. 内存复制从src_kvaddr到dst_kvaddr，大小为PGSIZE

现在有了源页面和目标页面的内核虚拟地址，可以使用`memcpy`函数将源页面的内容复制到目标页面。这一步是COW机制的核心，确保当发生写操作时，写入的是页面的私有拷贝。

```c
memcpy((void *)dst_kvaddr, (const void *)src_kvaddr, PGSIZE);
```

#### 4. 建立物理地址与线性地址start的映射

复制完成后，需要在目标进程的页表中建立物理地址与线性地址的映射。这可以通过`page_insert`函数实现，该函数将目标页面的物理地址与线性地址`start`建立映射，并设置相应的权限。

```c
ret = page_insert(to, npage, start, perm);
```

### Copy on Write机制的设计实现

#### 概要设计

Copy on Write（COW）机制的实现可以分为以下几个关键步骤：

1. **页面标记**：在操作系统的页表中，需要有一种方式来标记哪些页面是共享的，哪些页面已经被复制（私有）。可以通过`copy_range`的share参数实现,在`copy_range`中要根`share`参数判断一下是应该直接复制还是共享。

2. **写时复制**：当进程尝试写入一个共享页面时，操作系统需要捕获这个写操作，通过触发一个异常。然后，操作系统会复制共享页面的内容到一个新的页面，并更新进程的页表，使其指向这个新的私有页面。
   - 当一个写操作导致异常时，操作系统首先检查页表项的`share`标志位。
   - 如果`share`为0，表示需要进行写时复制。操作系统复制页面内容到新的物理页，并设置`share`标志位为1。
   - 更新进程的页表，将原来的共享页面映射指向新的私有页面。
   - 如果`share`标志位为1，表示页面已经是私有的，操作系统可以直接处理写操作。

3. **页表更新**：在复制页面后，操作系统需要更新进程的页表，将原来的共享页面映射改为指向新的私有页面。

4. **内存管理**：操作系统需要跟踪所有共享页面和私有页面的状态，以便于管理内存和优化性能。
   - 操作系统需要维护一个数据结构来跟踪所有共享页面和私有页面的状态，例如使用哈希表或树结构。
   - 当进程退出时，操作系统需要回收所有私有页面，并检查是否有其他进程共享相同的页面，如果有，则保持页面不变；如果没有，则释放页面。

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现

### fork/exec/wait/exit的执行流程分析

在操作系统中，`fork`、`exec`、`wait`和`exit`是进程控制的基本系统调用。这些系统调用涉及到用户态和内核态之间的交互。下面是这些系统调用的执行流程分析：

#### fork()
1. **用户态**：`fork()`函数在用户态被调用，它是一个库函数，其内部调用`sys_fork()`。
2. **内核态**：`sys_fork()`是一个系统调用，它通过`syscall`触发内核态的`sys_fork()`函数。在内核态，`do_fork()`函数负责实际的进程复制工作，包括复制进程的地址空间、打开文件描述符等，并设置适当的进程状态。
3. **返回内核态到用户态**：`do_fork()`执行完毕后，通过返回值将控制权交回用户态。在父进程中，`fork()`返回子进程的PID；在子进程中，`fork()`返回0。

#### exec()
1. **用户态**：`exec()`函数在用户态被调用，它是一个库函数，其内部调用`sys_exec()`。
2. **内核态**：`sys_exec()`是一个系统调用，它通过`syscall`触发内核态的`sys_exec()`函数。在内核态，`do_execve()`函数负责加载新的程序到当前进程的地址空间，并设置程序的入口点。
3. **返回内核态到用户态**：`do_execve()`执行完毕后，新的程序将在当前进程的地址空间中开始执行。如果`exec()`调用失败，控制权会返回到用户态，`exec()`函数会返回错误码。

#### wait()
1. **用户态**：`wait()`函数在用户态被调用，它是一个库函数，其内部调用`sys_wait()`。
2. **内核态**：`sys_wait()`是一个系统调用，它通过`syscall`触发内核态的`sys_wait()`函数。在内核态，`do_wait()`函数负责阻塞调用进程直到其子进程之一结束。
3. **返回内核态到用户态**：`do_wait()`执行完毕后，通过返回值将控制权交回用户态，并可能返回子进程的PID和退出状态。

#### exit()
1. **用户态**：`exit()`函数在用户态被调用，它是一个库函数，其内部调用`sys_exit()`。
2. **内核态**：`sys_exit()`是一个系统调用，它通过`syscall`触发内核态的`sys_exit()`函数。在内核态，`do_exit()`函数负责清理进程资源，并通知父进程。
3. **返回内核态到用户态**：通常，`exit()`函数不应该返回。如果`do_exit()`执行后进程仍然存在，说明`exit()`调用失败，通常会在用户态打印错误信息并进入无限循环。

### 用户态与内核态的交错执行

用户态与内核态之间的交错执行通常是通过系统调用来实现的。在用户态，当需要操作系统提供的服务时，会通过`syscall`指令触发系统调用，进入内核态执行相应的内核函数。内核函数执行完毕后，通过返回指令将控制权交回用户态。

### 内核态执行结果的返回

内核态执行的结果通常是通过返回值传递给用户态的。对于成功执行的系统调用，内核函数会设置特定的返回值；对于失败的系统调用，内核函数会设置错误码。这些返回值或错误码在用户态可以通过`fork()`、`exec()`、`wait()`和`exit()`函数的返回值来获取。

#### 用户态进程的执行状态生命周期图

```
+-------------------+     +-------------------+     +-------------------+
|   创建进程         | --> |   wait()          | --> |      RUNNING      |
|   (UNINIT)        |     |                   |     |                   |
+--------^----------+     +----^--------------+     +-----------^-------+
         |                          |               |
         v                          v               v
+--------+----------+     +----+--------------+     +-----------+-------+
| alloc_page()      |     |                   |     |   proc_run()      |
| (UNINIT -->       |<--- |                   |<--- | (RUNNABLE -->     |
|   RUNNABLE)       |     |                   |     |   RUNNING)        |
+--------+----------+     +-------------------+     +-----------+-------+
         |                          |               |
         +----------^---------------+               |
                   |                                |
                   v                                v
+--------+----------+     +-------------------+     +-----------+-------+
|   wakeup_proc()   |     |                   |     |   exit()          |
| (RUNNABLE -->     |<--- |                   |<--- | (RUNNING -->      |
|   UNINIT)         |     |                   |     |   ZOMBIE)         |
+--------+----------+     +-------------------+     +-----------+-------+
         |                           |                         |
         +---------------------------+                         |
                        |                                      |
                        v                                      v
+-----------------------------------------------------+-------------------+
|  子进程调用exit()                                    |  父进程调用wait()  |
|   (RUNNING --> ZOMBIE)                              |                   |
+-----------------------------------------------------+-------------------+
```

### 流程图说明：

- **创建进程**：进程从UNINIT状态开始。
- **alloc_page()**：为进程分配内存，状态从UNINIT变为RUNNABLE。
- **wakeup_proc()**：进程被唤醒，准备运行。
- **proc_run()**：进程开始运行，状态变为RUNNING。
- **exit()**：进程执行退出操作，状态从RUNNING变为ZOMBIE。
- **wait()**：父进程调用wait()，等待子进程结束。

## 扩展练习1
### 实现源码
在vmm.c中将dup_mmap中的share变量的值改为1，启用共享。
```c
int
dup_mmap(struct mm_struct *to, struct mm_struct *from) {
    ...
    bool share = 1;
}
```
在pmm.c中为copy_range添加对共享的处理，如果share为1，那么将子进程的页面映射到父进程的页面。由于两个进程共享一个页面之后，无论任何一个进程修改页面，都会影响另外一个页面，所以需要子进程和父进程对于这个共享页面都保持只读。
```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share) {
                if (*ptep & PTE_V) {
                    ...
                    if (share) {
                page_insert(from,page,start,perm&(~PTE_W));
                ret = page_insert(to,page,start,perm&(~PTE_W));
            } else {
                struct Page *npage=alloc_page();
                assert(npage!=NULL);
                uintptr_t src_kvaddr = page2kva(page);
                uintptr_t dst_kvaddr = page2kva(npage);
                memcpy((void *)dst_kvaddr, (const void *)src_kvaddr, PGSIZE); // (3) memory copy
                ret = page_insert(to, npage, start, perm); // (4) build the map
            }
                }
               }

```

当程序尝试修改只读的内存页面的时候，将触发Page Fault中断，在错误代码中P=1,、W/R=1。因此，当错误代码最低两位都为1的时候，说明进程访问了共享的页面，内核需要重新分配页面、拷贝页面内容、建立映射关系。

```c
int
do_pgfault(struct mm_struct *mm, uint_t error_code, uintptr_t addr) {
if (*ptep == 0) { 
    ...
}else if((*ptep&PTE_V)&&(error_code&3==3)){
        struct Page*page=pte2page(*ptep);
        struct Page*npage=pgdir_alloc_page(mm->pgdir,addr,perm);
        uintptr_t src_kvaddr=page2kva(page);
        uintptr_t dst_kvaddr=page2kva(npage);
        memcpy(dst_kvaddr,src_kvaddr,PGSIZE);
    }else{
        ...
    }
}
```
### 执行结果

可以看到Copy on Write正确执行。

![alt text](a268dceb23e24b30650ef547142d79c.jpg)

## 扩展练习2
在本次实验中，用户程序在编译时被静态链接到内核中，并在链接过程中就已确定了程序的起始位置和大小。当执行 user_main() 函数时，通过宏 KERNEL_EXECVE 调用 kernel_execve() 函数，从而触发加载程序的操作，进而调用 load_icode() 函数将用户程序加载到内存中。这种方式实现了通过一个内核进程将整个用户程序直接加载到内存。

而在我们常见的操作系统中，用户程序通常存储在外部存储设备上，作为独立的文件存在。当需要执行某个程序时，操作系统会从磁盘等外部存储介质动态地加载该程序到内存中。

我们之所以采用这种加载方式，是因为 ucore 操作系统并未实现硬盘支持和文件系统。出于简化设计和教学的考虑，将用户程序直接编译到内核中可以有效减少实现的复杂度。
