# Lab 2: 练习 1

该程序的物理内存分配过程如下：

1. **初始化**：
  通过 `default_init` 和 `default_init_memmap` 初始化空闲列表和页属性。
  
2. **分配页面**：
  当调用 `default_alloc_pages` 时，系统遍历空闲列表，找到符合请求的空闲块，更新其属性并返回指向已分配页面的指针。

3. **释放页面**：
  在调用 `default_free_pages` 时，将释放的页面重新加入空闲列表，并根据需要合并相邻的空闲块。

## 各个函数的功能描述

### `default_init` 函数
用于初始化物理内存管理系统，主要负责设置空闲页面列表和空闲页面数量。该函数首先通过调用 `list_init(&free_list)` 初始化空闲列表 `free_list`，确保在后续的分配和释放过程中能够正确管理空闲页面。接着，将空闲页面计数器 `nr_free` 初始化为 0，表示当前没有可用的空闲页面。这一初始化过程为后续的内存分配和释放奠定了基础。

### `default_init_memmap` 函数
负责将指定的物理内存区域映射到内存管理系统中，并初始化该区域的页面状态。该函数接受两个参数：`base`（内存区域的起始地址）和 `n`（表示要映射的页面数量）。函数内部会遍历每一页并初始化其标志和属性。特别地，对于空闲块的第一个页面，将其 `property` 属性设置为总页数，而其他页面则设置为 0。通过将这些页面添加到空闲列表 `free_list`，该函数确保新映射的页面在后续分配中可用，并更新 `nr_free` 以反映当前空闲页面的总数。

### `default_alloc_pages` 函数
用于处理页面分配请求。它接受一个参数 `n`，表示请求分配的页面数量。函数首先检查当前的空闲页面数量是否足够，如果不够则返回 `NULL`。接着，它遍历空闲列表 `free_list`，寻找第一个满足请求的空闲块。找到后，函数会设置该页面的 `PG_reserved` 标志，表示该内存区域已被分配。如果所找到的空闲块大于请求的页面数量，函数会更新剩余块的属性并将其重新加入到 `free_list` 中。最后，函数通过更新 `nr_free` 减少空闲页面数量，并返回指向已分配页面的指针以供后续使用。

### `default_free_pages` 函数
用于释放先前分配的页面，并将这些页面重新加入空闲列表。它接受两个参数：`base`（要释放页面的起始地址）和 `n`（要释放的页面数量）。在函数内部，会遍历要释放的页面，重置每个页面的标志和属性，以确保它们可以再次使用。对于释放的页面，`base` 页的 `property` 属性会被设置为 `n`，以表示该块的空闲页面数量已更新。然后，函数将这些释放的页面插入到 `free_list` 中，并检查相邻的空闲块是否可以合并。如果相邻的空闲块可以合并，函数将进行合并并更新其属性。

# Lab2：Challenge1
## 伙伴系统设计文档
### 伙伴系统概述
伙伴系统确实将系统中的可用存储空间划分为块，每个块的大小是 2 的 n 次幂，以便高效地管理不同大小的内存需求。每个块的大小是按物理页的数量来划分，因此，对于一个一般的块，可以包含 1 页、2 页、4 页、8 页等，以此类推。这样，分配和合并内存时就可以依据块大小的指数进行管理。
### 伙伴系统相关数据

- **`buddy_page`**：`int *` 类型，用于管理内存块的状态，存储每个内存块的可用页面数。
- **`buddy_page_num`**：`int` 类型，表示可管理的伙伴页数。
- **`useable_page_num`**：`int` 类型，表示实际可用的内存页面数。
- **`useable_page_base`**：`Page*` 类型，指向可用内存页面的基地址。

`struct Page` 结构体用于描述和管理物理内存中的页面状态，支持页面的分配、释放和状态查询。该结构体包含以下四个字段：

1. **`ref`**：表示页面的引用计数，用于跟踪页面是否正在被使用，以便在引用计数为零时将页面标记为空闲。
2. **`flags`**：状态标志字段，记录页面的各种状态标志位（例如是否被分配或锁定），从而实现对页面当前状态的快速判断。
3. **`property`**：记录当前页面所属的连续空闲页面块的大小，仅在 first-fit 分配策略中生效，便于快速定位符合条件的内存块。
4. **`page_link`**：作为链表节点，支持页面在空闲链表或特定页面链表中的插入和删除操作。

### 伙伴系统函数设计

#### `buddy_init_memmap` 函数

1. **参数检查**  
   首先检查输入参数 `n` 是否大于 0，其中 `n` 表示系统中可管理的页面总数。若 `n` 为 0 或不满足条件，则直接报错退出。

2. **计算伙伴系统参数**  

   - **`useable_page_num`**：表示可用的页面总数。通过位移操作(因为是伙伴系统，分配的页面数是2的n次幂形式)逐层增加页面数，用总页面数 `n`来卡住可用页和管理页之和，并通过这个条件求出最接近`n`的可用页页数，对应二叉树结构的叶子节点。
   - **`buddy_page_num`**：表示管理页面所需的节点数。根据伙伴系统树形结构的深度，计算出需预留的管理页面数，因为逻辑地址是39位，并且设计的是三级页表，基本上每一级页表直接相连的节点最多有2的9次幂，所以可用页页数除以512就是管理页的页数，至少为1,所以手动再加1即可。

3. **内存预留与权限设定**  

   - 为支持伙伴系统的管理结构，在物理内存的起始位置预留 `buddy_page_num` 个页面，并将这些页面标记为 `Reserved`。
   - 将剩余页面（即从 `buddy_page_num` 开始的页面）设置为可用，并初始化其属性为 `Property`，以表明这些页面是空闲的，可以被分配。

4. **初始化伙伴管理数组**  

   - `buddy_page` 数组位于内核虚拟地址空间，记录每个页面的状态。数组从底层叶节点开始初始化，设置每个叶节点的初始页面大小为 1。
   - 从叶节点逐层向上计算出每个节点的容量。利用二叉树的特点，向上合并页面信息，使每个父节点存储其子节点的最大页面数。

5. **输出初始化信息**  

   - 函数在完成内存映射后，输出总页面数、管理页面数和可用页面数的信息，以提供调试参考。

#### `buddy_alloc_pages` 函数

1. **参数检查与边界条件判断**  
   - 检查 `n` 的值是否大于 0，不符合条件则直接报错退出。
   - 判断 `n` 是否大于根节点（`buddy_page[1]`）的最大空闲页面数，若是，则说明没有足够的空间分配所需页面，函数返回 `NULL` 表示分配失败。

2. **查找合适的内存块**  
   - 从根节点开始，通过二叉树遍历方式查找最接近所需页面数 `n` 的节点。
   - 如果左子节点的空闲页面数量大于或等于 `n`，则继续向左遍历；否则检查右子节点，并进行相同的判断。
   - 当找到满足条件的最小块时，该节点即为符合要求的页面块。

3. **分配内存块**  
   - 确定页面块的实际大小（`size`）并清零相应节点的记录，以表明该块已被分配。
   - 计算出页面的起始位置（`new_page`），并初始化分配块中的每个页面，清除 `Property` 标记，表示页面已被占用。

4. **更新父节点的空闲信息**  
   - 从子节点向父节点回溯，更新节点信息。对于每个父节点，重新计算并记录其子节点的最大页面块大小。
   - 这样确保上层节点的空闲状态随分配操作同步更新，保证下一次分配时的状态一致性。

5. **返回结果**  
   - 返回分配到的页面块的起始地址 `new_page`。
  
#### `buddy_free_pages` 函数

1. **参数验证与释放标记设置**  
   - 检查参数 `n` 是否大于 0，以确保释放操作的有效性。
   - 遍历要释放的每个页面，确保它们都是已分配且无 `Property` 标记的页面。
   - 为每个释放的页面设置 `Property` 标记，并重置引用计数（`ref`）为 0，以表明页面已回到空闲状态。

2. **获取释放块的起始节点和大小**  
   - 根据 `base` 参数（释放页面的起始地址）计算相应的节点索引位置 `index` 和块的初始大小 `size`，从树底部开始回溯更新空闲信息。
   - 确保 `buddy_page[index]` 处的值为 0，标识该页面块不再被使用，以便进行进一步的合并。

3. **更新节点信息并进行伙伴合并**  
   - 自底向上更新树的节点信息：在节点上记录所释放的块大小，同时检查该节点是否可以与其伙伴节点合并。
   - 若左、右子节点的空闲页数之和等于当前层的块大小 `size`，则将它们合并为更大的空闲块。
   - 若不能完全合并，则将父节点的空闲值设为两个子节点中较大的值，以确保分配和释放后的结构准确。

4. **完成释放**  
   - 当节点遍历到根节点时，整个伙伴合并过程结束，完成释放操作。
   - 此时，伙伴系统已将页面成功释放回空闲内存池，确保系统空闲状态随释放操作同步更新完毕。

#### `buddy_nr_free_pages`函数
返回buddy_page[1],返回根节点的空闲页数量，来判定需求是否合法。

#### `buddy_check`函数
`buddy_check` 测试设计需求：

1. **合法性检查**  
  测试过程中尝试分配超出系统可用页面数量的请求，确保函数能够识别并拒绝不合理的内存请求，以验证伙伴系统的边界处理是否正确。

2. **连续性检查**  
  测试在伙伴系统中分配的页面是否满足连续性需求。例如，通过分配不同大小的页面组（如1页、2页等）并检查相邻组的起始地址是否紧密相邻，从而验证系统的分配逻辑是否准确。

3. **回收后状态检查**  
  在释放已分配页面后，再次请求分配时，检查释放页面的状态是否恢复为可用状态，包括 Property 标记的重设和引用计数的重置，确保伙伴系统在释放内存后能够正确复用这些页面。

4. **合并和复用检查**  
  在回收页面后，系统是否能够有效地合并相邻的空闲块，以最大化内存利用率，减少内存碎片，并确保后续分配中能够有效复用这些合并后的空闲块。
