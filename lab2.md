# Lab 2: 练习 1

该程序的物理内存分配过程如下：

1. **初始化**：
  通过 `default_init` 和 `default_init_memmap` 初始化空闲列表和页属性。
  
2. **分配页面**：
  当调用 `default_alloc_pages` 时，系统遍历空闲列表，找到符合请求的空闲块，更新其属性并返回指向已分配页面的指针。

3. **释放页面**：
  在调用 `default_free_pages` 时，将释放的页面重新加入空闲列表，并根据需要合并相邻的空闲块。

## 各个函数的功能描述

### `default_init` 函数
用于初始化物理内存管理系统，主要负责设置空闲页面列表和空闲页面数量。该函数首先通过调用 `list_init(&free_list)` 初始化空闲列表 `free_list`，确保在后续的分配和释放过程中能够正确管理空闲页面。接着，将空闲页面计数器 `nr_free` 初始化为 0，表示当前没有可用的空闲页面。这一初始化过程为后续的内存分配和释放奠定了基础。

### `default_init_memmap` 函数
负责将指定的物理内存区域映射到内存管理系统中，并初始化该区域的页面状态。该函数接受两个参数：`base`（内存区域的起始地址）和 `n`（表示要映射的页面数量）。函数内部会遍历每一页并初始化其标志和属性。特别地，对于空闲块的第一个页面，将其 `property` 属性设置为总页数，而其他页面则设置为 0。通过将这些页面添加到空闲列表 `free_list`，该函数确保新映射的页面在后续分配中可用，并更新 `nr_free` 以反映当前空闲页面的总数。

### `default_alloc_pages` 函数
用于处理页面分配请求。它接受一个参数 `n`，表示请求分配的页面数量。函数首先检查当前的空闲页面数量是否足够，如果不够则返回 `NULL`。接着，它遍历空闲列表 `free_list`，寻找第一个满足请求的空闲块。找到后，函数会设置该页面的 `PG_reserved` 标志，表示该内存区域已被分配。如果所找到的空闲块大于请求的页面数量，函数会更新剩余块的属性并将其重新加入到 `free_list` 中。最后，函数通过更新 `nr_free` 减少空闲页面数量，并返回指向已分配页面的指针以供后续使用。

### `default_free_pages` 函数
用于释放先前分配的页面，并将这些页面重新加入空闲列表。它接受两个参数：`base`（要释放页面的起始地址）和 `n`（要释放的页面数量）。在函数内部，会遍历要释放的页面，重置每个页面的标志和属性，以确保它们可以再次使用。对于释放的页面，`base` 页的 `property` 属性会被设置为 `n`，以表示该块的空闲页面数量已更新。然后，函数将这些释放的页面插入到 `free_list` 中，并检查相邻的空闲块是否可以合并。如果相邻的空闲块可以合并，函数将进行合并并更新其属性。

# LAB2：练习2

## 实验目的

实现 Best-Fit 连续物理内存分配算法，并理解其工作原理和优化空间。

## 实验步骤

1. **理解Best-Fit算法**：Best-Fit算法是一种内存分配策略，它会选择一个大小能够满足请求且最小的空闲内存块进行分配。这样可以减少内存碎片，提高内存利用率。

2. **修改内存管理器**：在`kern/mm/best_fit_pmm.c`中，修改内存管理器的相关函数，以实现Best-Fit算法。

3. **初始化内存管理器**：在`best_fit_init`函数中，初始化空闲内存列表和空闲内存计数器。

4. **初始化内存映射**：在`best_fit_init_memmap`函数中，初始化每个内存页，并将其添加到空闲内存列表中。

5. **分配内存**：在`best_fit_alloc_pages`函数中，实现Best-Fit算法的分配逻辑，找到最小的能满足请求的空闲内存块，并进行分配。

6. **释放内存**：在`best_fit_free_pages`函数中，实现内存释放逻辑，并将释放的内存块添加回空闲内存列表。

7. **测试**：编写测试用例，验证Best-Fit算法的正确性。

## 实验结果

通过编写和运行测试用例，验证了Best-Fit算法的正确性。测试结果显示，算法能够正确地分配和释放内存，并且能够找到最小的能满足请求的空闲内存块。

## 实验分析
### Best-Fit算法与First-Fit算法区别

Best-Fit算法与First-Fit算法的主要区别在于，Best-Fit算法会选择最小的能满足请求的空闲内存块，而First-Fit算法会选择第一个能满足请求的空闲内存块。所以Best-Fit算法更加好。
# Lab2：Challenge1
## 伙伴系统设计文档
### 伙伴系统概述
伙伴系统确实将系统中的可用存储空间划分为块，每个块的大小是 2 的 n 次幂，以便高效地管理不同大小的内存需求。每个块的大小是按物理页的数量来划分，因此，对于一个一般的块，可以包含 1 页、2 页、4 页、8 页等，以此类推。这样，分配和合并内存时就可以依据块大小的指数进行管理。
### 伙伴系统相关数据

- **`buddy_page`**：`int *` 类型，用于管理内存块的状态，存储每个内存块的可用页面数。
- **`buddy_page_num`**：`int` 类型，表示可管理的伙伴页数。
- **`useable_page_num`**：`int` 类型，表示实际可用的内存页面数。
- **`useable_page_base`**：`Page*` 类型，指向可用内存页面的基地址。

`struct Page` 结构体用于描述和管理物理内存中的页面状态，支持页面的分配、释放和状态查询。该结构体包含以下四个字段：

1. **`ref`**：表示页面的引用计数，用于跟踪页面是否正在被使用，以便在引用计数为零时将页面标记为空闲。
2. **`flags`**：状态标志字段，记录页面的各种状态标志位（例如是否被分配或锁定），从而实现对页面当前状态的快速判断。
3. **`property`**：记录当前页面所属的连续空闲页面块的大小，仅在 first-fit 分配策略中生效，便于快速定位符合条件的内存块。
4. **`page_link`**：作为链表节点，支持页面在空闲链表或特定页面链表中的插入和删除操作。

### 伙伴系统函数设计

#### `buddy_init_memmap` 函数

1. **参数检查**  
   首先检查输入参数 `n` 是否大于 0，其中 `n` 表示系统中可管理的页面总数。若 `n` 为 0 或不满足条件，则直接报错退出。

2. **计算伙伴系统参数**  

   - **`useable_page_num`**：表示可用的页面总数。通过位移操作(因为是伙伴系统，分配的页面数是2的n次幂形式)逐层增加页面数，用总页面数 `n`来卡住可用页和管理页之和，并通过这个条件求出最接近`n`的可用页页数，对应二叉树结构的叶子节点。
   - **`buddy_page_num`**：表示管理页面所需的节点数。根据伙伴系统树形结构的深度，计算出需预留的管理页面数，因为逻辑地址是39位，并且设计的是三级页表，基本上每一级页表直接相连的节点最多有2的9次幂，所以可用页页数除以512就是管理页的页数，至少为1,所以手动再加1即可。

3. **内存预留与权限设定**  

   - 为支持伙伴系统的管理结构，在物理内存的起始位置预留 `buddy_page_num` 个页面，并将这些页面标记为 `Reserved`。
   - 将剩余页面（即从 `buddy_page_num` 开始的页面）设置为可用，并初始化其属性为 `Property`，以表明这些页面是空闲的，可以被分配。

4. **初始化伙伴管理数组**  

   - `buddy_page` 数组位于内核虚拟地址空间，记录每个页面的状态。数组从底层叶节点开始初始化，设置每个叶节点的初始页面大小为 1。
   - 从叶节点逐层向上计算出每个节点的容量。利用二叉树的特点，向上合并页面信息，使每个父节点存储其子节点的最大页面数。

5. **输出初始化信息**  

   - 函数在完成内存映射后，输出总页面数、管理页面数和可用页面数的信息，以提供调试参考。

#### `buddy_alloc_pages` 函数

1. **参数检查与边界条件判断**  
   - 检查 `n` 的值是否大于 0，不符合条件则直接报错退出。
   - 判断 `n` 是否大于根节点（`buddy_page[1]`）的最大空闲页面数，若是，则说明没有足够的空间分配所需页面，函数返回 `NULL` 表示分配失败。

2. **查找合适的内存块**  
   - 从根节点开始，通过二叉树遍历方式查找最接近所需页面数 `n` 的节点。
   - 如果左子节点的空闲页面数量大于或等于 `n`，则继续向左遍历；否则检查右子节点，并进行相同的判断。
   - 当找到满足条件的最小块时，该节点即为符合要求的页面块。

3. **分配内存块**  
   - 确定页面块的实际大小（`size`）并清零相应节点的记录，以表明该块已被分配。
   - 计算出页面的起始位置（`new_page`），并初始化分配块中的每个页面，清除 `Property` 标记，表示页面已被占用。

4. **更新父节点的空闲信息**  
   - 从子节点向父节点回溯，更新节点信息。对于每个父节点，重新计算并记录其子节点的最大页面块大小。
   - 这样确保上层节点的空闲状态随分配操作同步更新，保证下一次分配时的状态一致性。

5. **返回结果**  
   - 返回分配到的页面块的起始地址 `new_page`。
  
#### `buddy_free_pages` 函数

1. **参数验证与释放标记设置**  
   - 检查参数 `n` 是否大于 0，以确保释放操作的有效性。
   - 遍历要释放的每个页面，确保它们都是已分配且无 `Property` 标记的页面。
   - 为每个释放的页面设置 `Property` 标记，并重置引用计数（`ref`）为 0，以表明页面已回到空闲状态。

2. **获取释放块的起始节点和大小**  
   - 根据 `base` 参数（释放页面的起始地址）计算相应的节点索引位置 `index` 和块的初始大小 `size`，从树底部开始回溯更新空闲信息。
   - 确保 `buddy_page[index]` 处的值为 0，标识该页面块不再被使用，以便进行进一步的合并。

3. **更新节点信息并进行伙伴合并**  
   - 自底向上更新树的节点信息：在节点上记录所释放的块大小，同时检查该节点是否可以与其伙伴节点合并。
   - 若左、右子节点的空闲页数之和等于当前层的块大小 `size`，则将它们合并为更大的空闲块。
   - 若不能完全合并，则将父节点的空闲值设为两个子节点中较大的值，以确保分配和释放后的结构准确。

4. **完成释放**  
   - 当节点遍历到根节点时，整个伙伴合并过程结束，完成释放操作。
   - 此时，伙伴系统已将页面成功释放回空闲内存池，确保系统空闲状态随释放操作同步更新完毕。

#### `buddy_nr_free_pages`函数
返回buddy_page[1],返回根节点的空闲页数量，来判定需求是否合法。

#### `buddy_check`函数
`buddy_check` 测试设计需求：

1. **合法性检查**  
  测试过程中尝试分配超出系统可用页面数量的请求，确保函数能够识别并拒绝不合理的内存请求，以验证伙伴系统的边界处理是否正确。

2. **连续性检查**  
  测试在伙伴系统中分配的页面是否满足连续性需求。例如，通过分配不同大小的页面组（如1页、2页等）并检查相邻组的起始地址是否紧密相邻，从而验证系统的分配逻辑是否准确。

3. **回收后状态检查**  
  在释放已分配页面后，再次请求分配时，检查释放页面的状态是否恢复为可用状态，包括 Property 标记的重设和引用计数的重置，确保伙伴系统在释放内存后能够正确复用这些页面。

4. **合并和复用检查**  
  在回收页面后，系统是否能够有效地合并相邻的空闲块，以最大化内存利用率，减少内存碎片，并确保后续分配中能够有效复用这些合并后的空闲块。

# LAB2:Challenge2 

这一实验旨在基于伙伴系统实现slub分配器，进一步优化内存分配的效率和管理。slub分配器通过对固定大小对象进行分组和缓存，以减少内存碎片，并提高频繁分配和释放对象的效率。

## 1.算法理解
slub 是基于 slab 分配器改进的内存分配器，与经典的伙伴系统不同，slub 针对频繁小对象分配需求进行了优化。一篇CSDN上用仓库和商户的角色分配的示例，将slub算法的原理讲得深入浅出：

仓库（Buddy 分配器）：负责管理内存的大块资源。它提供“货物”（内存页）给“商户”，并且只处理大块的存储分配。每当商户需要一批新的小物品时，仓库就提供一整块货物（通常是一个 4KB 的页面）给商户。

商户（SLUB 分配器）：负责将仓库中的大块资源进一步拆分成更小的对象，并精细化地分配给顾客（用户程序）。商户根据顾客的需求大小，设立了多个特定尺寸的货架，以便顾客可以快速获取所需物品。

同时，商户为每种尺寸的物品设立了货架（kmem_cache），每个缓存池专门存放某种大小的对象，比如 8 字节、16 字节等。货架上商品的组织就是slab：每个货架包含多个商品架（slab），每个商品架在商户的管理下由一个完整的页面（4KB）组成。商户从仓库获取整页的货物，然后将其填充在不同的货架上。

顾客需求的分配： 当顾客需要一个小对象时，商户会在对应的货架上找到合适的商品架。如果当前架子上有未使用的空间（空闲对象），则分配给顾客；如果当前架子已满，则商户会从货架上的空闲链表或部分使用的链表中找到合适的架子，并为顾客提供对象。如果货架已无空闲的商品架，商户会向仓库申请新的货物并添加到货架上。

商品回收：就是前面过程的反步骤，当下一级全部释放后，往上一级进行归回，将内存返回。

## 2. 代码实现
代码的实现基于 `buddy_pmm` 文件中的伙伴算法，扩展了slub分配器的内存管理功能，并提供了一组接口来分配和释放对象。

### 2.1 引入依赖头文件
在代码的开头，引入了必要的头文件，主要是将同伴写的伙伴算法纳入了进来：
```c
#include <pmm.h>
#include <list.h>
#include <string.h>
#include <buddy_pmm.h>
#include <stdio.h>
#include <defs.h>
```
pmm.h：包含物理内存管理器的基础定义和接口。

list.h：提供双向链表结构和操作函数，用于实现 slab 链表。

string.h、stdio.h 和 defs.h：提供字符串处理、输入输出和常量定义。

buddy_pmm.h：伙伴分配器的头文件，提供页级分配的基础功能。

### 2.2 定义 SLUB 分配器结构体
SLUB 分配器的两个主要结构体是 `kmem_cache` 和 `slab`：

```c
struct kmem_cache {
    size_t object_size;
    struct list_head slabs_full;
    struct list_head slabs_partial;
    struct list_head slabs_free;
};

struct slab {
    struct list_head list;
    unsigned int free_count;
    unsigned int in_use;
    void *free_list;
};
```

`kmem_cache`：定义对象缓存管理器，也就是算法理解中的“仓库”。其中的具体变量含义为：

①`object_size`：指定每个对象的大小，

②`slabs_full`：存储已满的slab的链表

③`slabs_partial`：存储部分使用的slab的链表

④`slabs_free`：存储空闲的slab的链表。

slab：表示单个slab，即运营商，需要对内存需求进行返回的算法部分，其中包含空闲对象的链表`free_list`，当前的空闲对象数 `free_count`，以及已分配对象数`in_use`。


### 2.3 初始化 SLUB 分配器
```c
static void slub_init(void) {
    for (int i = 0; i < SLUB_MAX_ORDER; i++) {
        struct kmem_cache *cache = &slub_caches[i];
        cache->object_size = 1 << (i + 3);
        list_init(&cache->slabs_full);
        list_init(&cache->slabs_partial);
        list_init(&cache->slabs_free);
    }
}
```
此函数初始化`slub_caches`，每个`kmem_cache`表示一个特定大小的对象缓存池。`object_size`依次设置为 8、16、32 字节等，巧妙地采用了位运算，从2的3次方开始不断×2，直至4096（2的11次方）。

### 2.4 初始化内存映射
```c
static void slub_init_memmap(struct Page *base, size_t n) {
    for (size_t i = 0; i < n; i++) {
        ClearPageProperty(&base[i]);
        SetPageReserved(&base[i]);
    }
}
```
该函数标记slub管理器所用页面为已分配。`ClearPageProperty`清除页面属性，`SetPageReserved`将页面标记为已保留，以防止伙伴系统重复分配这些页面。

尽管`slub_init_memmap`并未直接将页面打碎，但slub分配器通过自身的`kmem_cache`和`slab`结构，在逻辑上将单个页面分为多个小对象。

### 2.5 对象分配函数
```c
void *slub_alloc(struct kmem_cache *cache) {
    struct slab *slab = NULL;

    if (!list_empty(&cache->slabs_partial)) {
        slab = list_entry(cache->slabs_partial.next, struct slab, list);
    } else if (!list_empty(&cache->slabs_free)) {
        slab = list_entry(cache->slabs_free.next, struct slab, list);
        list_del(&slab->list);
        list_add(&cache->slabs_partial, &slab->list);
    } else {
        struct Page *page = buddy_alloc_pages(1);
        slab = (struct slab *)KADDR(page2pa(page));
        memset(slab, 0, MAX_SLAB_SIZE);
        list_add(&cache->slabs_partial, &slab->list);
    }

    void *object = slab->free_list;
    slab->free_list = *(void **)slab->free_list;
    slab->in_use++;
    if (slab->in_use == cache->object_size) {
        list_del(&slab->list);
        list_add(&cache->slabs_full, &slab->list);
    }
    return object;
}
```
首先查找`slabs_partial`中的`slab`，若没有部分使用的 slab，则尝试从`slabs_free`获取。如果都为空闲，分配一个新页，并初始化为一个新的`slab`。

接着进行对象分配：将`slab->free_list`中的对象地址返回并更新 `free_list`指向下一个对象。

### 2.6 对象释放函数
```c
void slub_free(struct kmem_cache *cache, void *object) {
    struct slab *slab = get_slab_from_object(object);
    *(void **)object = slab->free_list;
    slab->free_list = object;
    slab->in_use--;

    if (slab->in_use == 0) {
        list_del(&slab->list);
        list_add(&cache->slabs_free, &slab->list);
    } else if (slab->in_use == cache->object_size - 1) {
        list_del(&slab->list);
        list_add(&cache->slabs_partial, &slab->list);
    }
}
```
此函数释放指定对象并将其重新链接回`slab->free_list`。当 `in_use`计数为 0 时，将该`slab`移动到`slabs_free`；若从满状态释放至部分使用，则移回`slabs_partial`。

### 2.7 测试函数与管理器导出
与前面逻辑相同，不再赘述。


# Lab2: Challenge3

## 硬件的可用物理内存范围的获取方法

如果操作系统无法提前知道当前硬件的可用物理内存范围，可以通过以下方法获取：

1. **BIOS调用**：在系统启动时，通过BIOS中断调用获取内存大小信息。
2. **E820规范**：在BIOS调用的基础上，E820规范提供了一种更详细的内存映射方法，可以获取到更精确的内存范围信息。
3. **ACPI**：现代计算机使用ACPI规范，其中包含了内存映射信息，可以通过ACPI表获取内存范围。

通过这些方法，操作系统可以在启动时获取到硬件的可用物理内存范围，并据此进行内存管理。
