# lab0.5
## 使用GDB验证启动流程
1.使用make debug指令启动QEMU模拟的RISC-V计算机。

2.使用make gdb指令启动GDB调试。


3.在GDB中，使用以下指令及作用：

x/10i 0x80000000

![alt text](97682ce2474065cec1a9951b9457245.png)

x/10i $pc : 显示即将执行的10条汇编指令。

![alt text](669fd1d095786f9a301b94c873f7bb9.png)

x/10xw 0x80000000

![alt text](7c87d5c140d39adb67ab0a46ed0d01e.png)

info register

![alt text](0e5294497b00672ccc5d9f565d6faec.png)

info r t0

break funcname

break *0x80200000

![alt text](72b80e1cb90fc5a713a143bafb13975.png)

continue

si

![alt text](292162f39e4588b2180a7adfdfb8167.png)

# lab1
## 练习1：理解内核启动中的程序入口操作
la sp, bootstacktop 指令设置了堆栈指针，以便内核可以使用一个预先分配的堆栈。tail kern_init 指令则是跳转到内核初始化函数，开始执行内核的初始化过程。这是操作系统启动流程中的典型步骤，确保内核有一个可用的堆栈，并且开始执行初始化代码。
## 练习2：完善中断处理
操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机

![alt text](bc2d3b8fa6556580d98804e1fcd4381.png)

运行结果如下

![alt text](2cf00dfabcb191b79ebf4d13e088e72.png)

## 扩展练习 Challenge1：描述与理解中断流程
### 在uCore操作系统中，处理中断和异常的流程大致如下：

1.中断/异常产生：当CPU检测到中断信号或异常时，会触发一个中断或异常处理。

2.保存当前状态：在进入中断或异常处理程序之前，CPU会将当前的状态（包括程序计数器、寄存器等）保存到一个称为堆栈的地方。

3.设置堆栈指针：在uCore中，mov a0, sp指令将堆栈指针sp的值移动到a0寄存器中。a0寄存器通常用于函数的第一个参数，这里它被用来传递当前的堆栈指针给中断处理程序。

4.调用中断处理函数：uCore会调用一个通用的中断处理函数，如__alltraps，来处理不同类型的中断和异常。

5.保存所有寄存器：在__alltraps函数中，使用SAVE_ALL宏来保存所有寄存器到堆栈中。这样做是为了在中断处理程序中使用寄存器时不会影响被中断的程序。

6.执行中断处理：中断处理程序会执行必要的操作来处理中断。

7.恢复寄存器状态：处理完成后，会使用RESTORE_ALL宏来恢复之前保存的所有寄存器的值。

8.返回：中断处理程序执行完毕后，会返回到被中断的程序，继续执行。

### mov a0, sp的目的
mov a0, sp的目的是在中断发生时，将当前的堆栈指针传递给中断处理程序，这样中断处理程序就可以访问到被中断程序的堆栈，从而保存和恢复寄存器状态。
SAVE_ALL中寄存器保存在栈中的位置是确定的，通常是按照一定的顺序将寄存器压栈。这个顺序通常是固定的，以确保在中断处理完成后可以按照相反的顺序恢复寄存器的值。

### 对于任何中断，__alltraps中都需要保存所有寄存器，理由如下：

上下文切换：中断处理程序可能会切换到不同的执行上下文，因此需要保存当前上下文的状态。
寄存器覆盖：中断处理程序可能会使用到这些寄存器，如果不保存，可能会覆盖掉被中断程序中寄存器的值。
恢复执行：中断处理完成后，需要恢复被中断程序的执行，这就需要恢复之前保存的寄存器状态。
在uCore中，__alltraps函数会保存和恢复所有寄存器，以确保中断处理程序不会影响其他程序的执行。
## 扩展练习 Challenge2：理解上下文切换机制
### 在trapentry.S文件中，处理中断和异常的汇编代码中，csrw sscratch, sp和csrrw s0, sscratch, x0指令实现了以下操作：

1.csrw sscratch, sp：这条指令将当前的堆栈指针（sp）的值写入到sscratch寄存器中。sscratch是一个系统寄存器，用于保存内核堆栈指针。这个操作的目的是保存当前内核堆栈指针，以便在中断处理程序中可以访问到正确的堆栈。

2.csrrw s0, sscratch, x0：这条指令读取sscratch寄存器的值，并将这个值写入到s0寄存器中。同时，x0寄存器的值（通常是0）被写入到sscratch寄存器中。这个操作的目的是将sscratch寄存器的值（即内核堆栈指针）保存到s0寄存器中，并将sscratch寄存器清零。清零sscratch寄存器的目的是防止递归异常的发生，因为如果发生递归异常，sscratch寄存器将被用来指示异常是从用户模式还是内核模式触发的。

### 在SAVE_ALL宏中，保存了stval（s3）、scause（s4）等控制状态寄存器（CSR），但在RESTORE_ALL宏中没有恢复这些寄存器。这是因为：

stval：保存了异常发生时的异常向量。在中断处理程序中，这个值用于确定异常的原因和上下文。

scause：保存了异常的原因。这个值对于调试和处理异常非常重要。

不恢复的原因：在中断处理程序完成后，通常不需要恢复这些寄存器的值，因为它们在中断处理程序中被用来确定中断的原因和上下文。一旦中断处理程序完成，这些值就不再需要了，而且恢复它们可能会导致不一致的状态。

sstatus和sepc的恢复：sstatus和sepc寄存器在RESTORE_ALL宏中被恢复，因为它们控制着CPU的状态和程序的执行点。sstatus控制着当前的特权级别和各种状态标志，而sepc保存了异常发生时的程序计数器的值，这两个寄存器的值对于恢复程序的执行非常重要。

## 扩展练习 Challenge3：完善异常中断
在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)

![alt text](84b79dce379755bb57537d5b75471e9.png)

“ebreak caught at 0x（地址）

![alt text](a2057ee0ef9f1dd0d3378a7c8b185c4.png)

运行结果

![alt text](3695714bae6e01d20728832e30ff5f9.png)